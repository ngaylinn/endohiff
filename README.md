# Ramps and Ratchets: Evolving Spatial Viability Landscapes

This repo holds the source code for the paper *Ramps and Ratchets: Evolving Spatial Viability Landscapes*, a research paper submitted to the [ALife 2025](https://www.alife-japan.org/alife-2025) conference.

Supplemental figures to accompany the paper can be found [here](./supp.md).

## Table of Contents
- [About this Project](#about-this-project)
- [Tour of the Code](#tour-of-the-code)
- [Installation](#installation)
- [Reproducing Results](#reproducing-results)

## About this Project

This project is inspired by endosymbiosis, where a host provides an evolved environment to suppor t the growth and evolution of a population of symbionts. It's also inspired by the MEGA-Plate experiment by Baym et al., summarized in this [short video](https://www.youtube.com/watch?v=plVk4NVIUh8). In that experiment, they showed how a gradient of antibiotics could lead bacteria to evolve antibiotic resistance as they migrated through space. Our aim was to reproduce and analyze the dynamics from the MEGA-Plate experiment, and to try evolving environments with viability gradients instead of designing them by hand.

The main output from the code in this repo is a pair of hyperparameter sweeps, looking at evolutionary dynamics under varying amounts of selection pressure and symbiont mobility. For each hyperparameter setting in these sweeps, we evolve a population of symbionts in two different static environments designed by hand. We also evolve environments to compare against the hand-designed ones, and evolve bit strings in those settings. In this case, our "symbionts" are just bit strings, whose fitness is determined by a function called HIFF, first proposed by Richard Watson.

For more details on the motivation, design, and results of this experiment, please see our paper.

## Tour of the Code

A brief overview of the directory and core scripts of this project. Not all files are listed

- `README.md`: This file.
- `supp.md`: A walkthrough of supplemental figures from the paper.
- `figures/`: Figures made by hand or generated by the code in this repo, for use in `supp.md`.
- `output/`: Where all outputs generated by the code in this repo are saved.
- `src/`: All code for this project
  - `sweep.py`: Script to visualize the results of hyperparameter sweeps.
  - `bitstrings/`: Code for evolving and visualizing bitstrings.
    - `sweep.py`: Script to run a hyperparameter sweep in a given environment, evolving a population of bitstrings for hyperparameter settings.
    - `visualize_fitness.py`: Script to visualize the fitness trajectory of evolving bitstring populations, and compare them between environments.
    - `visualize_population.py`: Script to visualize the fitness of a population of evolving bitstrings as a spatial map. Can generate either static images of the final generation, or animations of the full evolutionary history.
  - `environments/`: Code for generating static and evolved environments, to host the evolution of bitstring populations within.
    - `sweep.py`: Script to run a hyperparameter sweep, evolving an environment for each setting.
    - `visualize_fitness.py`: Script to visualize the fitness trajectory of evolving environment populations.
    - `visualize_one.py`: Script to visualize a single environment, either static or evolved.


## Installation

The dependencies for this project are listed in [`environment.yml`](./environment.yml). These can be installed automatically using a tool such as [Conda](https://docs.conda.io/projects/conda/en/stable/), or manually.

This code also depends on a prototype library called [Neatchi](https://github.com/ngaylinn/neatchi) that provides a version of the NEAT algorithm that runs entirely on GPU. Since this is not yet intended for a general audience, it must be installed manually using `git clone`, either into the directory for this project or elsewhere in the Python path.

## Reproducing Results

This code is designed to run on a single CUDA-enagled NVidia GPU. Because it uses the [Taichi](https://www.taichi-lang.org/) programming language for GPU support, it should be possible to adapt the code to work on other systems, including without a GPU, but this is unsupported.

The program is currently optimized to require about 20GB of GPU memory, but could be modified to use much less. The easiest way to do this would be to modify `src/constants.py`. Specifically, the overall size of the experiment is determined by the product of `ENV_SHAPE`, `ENV_POPULATION_SIZE`, and `NUM_TRIALS`, so making any of these smaller will drammatically reduce the memory requirements. Running the full-scale experiment with less memory is also possible, but would require modifing the code in `src/bitstrings/sweep.py` and `src/environments/sweep.py` to run experiments in sequence instead of in parallel.

This experiment relies heavily on randomness, so the results will be different on each run. They should be qualitatively similar to the results published in our paper, but not exactly the same.

To reproduce the full results from this experiment, simply run `snakemake all --resources gpu=1`. This will run all experiments and rebuild all visualizations using the full resources available on the machine where it is run. On our desktop workstation, this takes approximately 42 hours to complete. Issues with out-of-memory errors or crashes may be addressed by adding `--cores N` where `N` is the number of processes to run in parallel. A smaller value of `N` will take longer to complete, but avoid overextending the system's memory.

The individual scripts in this repo can also be run on their own to reproduce subsets of the full experiment. They should be run *as modules* from the repo root directory. For instance, from the `endohiff` directory, run `python3 -m src.extras.visualize_hiff output/hiff.png`. See the script files themselves for comments and documentation on how to use them.
